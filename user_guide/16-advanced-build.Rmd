---
editor_options: 
  markdown: 
    wrap: 72
---

# Advanced Build Process {#ve-buildprocess}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results='hide')
```

## Introduction

This chapter contains miscellaneous content as part of building
VisionEval packages. Although not necessary to going through the Build
Process chapter, the information may be useful for more advanced users.

1.  VisionEval Package Structure
2.  Build from command line
3.  PUMS data processing helper scripts
4.  Modifying package code

## VisionEval Package Structure

VisionEval packages will generally have a structure similar to the
following:

    source/modules/VEGenericPackage
    ├───data
    │   ├─ GenericPackageSpecifications.rda
    │   ├─ GenericPackage_df.rda
    │   └─ GenericPackage_ls.rda
    ├───R
    │   ├─ CreateEstimationDatasets.R
    │   └─ GenericModel.R
    └───inst
        └─ extdata
            ├─ input_data1.csv
            └─ input_data2.txt

-   `inst\extdata` is where "external" input data sources and reference
    files will be placed

-   The `R` directory contains any R scripts used in the packages. These
    must be independent non-sequential scripts that do not depend on
    results from other scripts.

-   `data` contains the resulting data that VisionEval generates and
    utilizes.

-   `man` and `inst\module_docs`, contain the markdown documentation
    generated during the build process.

## Build from command line

While the GUI method is intuitive, it can be convenient to simply
execute a build command from a generic R session rather than navigating
menu trees in the GUI.

The fundamental command to build an r package can be run from R console
using `system("R CMD INSTALL package_path -l lib_path")`. The GUI method
essentially constructs this command and executes it.

-   `package_path` is the path to the package you are building. If your
    working directory is already located in the package, you can use `.`
    to denote the local directory.
-   `lib_path` is the runtime environment, in this case the VisionEval
    environment:

<!-- -->

    system("R CMD INSTALL "C:\Users\<user name>\Documents\VisionEval-source\sources\modules\VESimHouseholds" -l "C:\Users\<user name>\Documents\VisionEval\ve-lib")

## PUMS data processing helper scripts

Processing PUMS data can be challenging for two reasons.

1.  PUMS data evolves, with some field names and levels changing.

```{=html}
<!-- -->
```
2.  The 2000 PUMS are stored in a compressible serial text file
    structure, rather a common delimited file (e.g., CSV), making
    importing tedious.

Below are some helper scripts for future users to build upon:

NOTE: These may not work with all PUMS file years, operating systems, or
R versions. Best effort was made to identify weak points (e.g.,
unzipping), but cannot be guaranteed. These scripts are meant to be a
starting point, not a production level code.

### PUMS File import and header processing

``` R
# IMPORTS
library(data.table)
library(tools)


# Function to process PUMS as it is read in
process_acs_pums <- function(PumsFile, type, GetPumas='ALL') {
  # ACS PUMS to legacy Census PUMS fields
  # Make any modifications here as necessary
  meta = list(
    'h' = list(
      SERIALNO = list(acsname = 'SERIALNO', class ='character'),
      PUMA5 = list(acsname='PUMA', class='character'),
      HWEIGHT = list(acsname='WGTP', class='numeric'),
      UNITTYPE = list(acsname='TYPE', class='numeric'),
      PERSONS = list(acsname='NP', class='numeric'),
      BLDGSZ = list(acsname='BLD', class='character'),
      HINC = list(acsname='HINCP', class='numeric')
    ),
    'p' = list(
      SERIALNO = list(acsname = 'SERIALNO', class ='character'),
      AGE = list(acsname='AGEP', class='numeric'),
      WRKLYR = list(acsname='WKL', class='character'),
      MILITARY = list(acsname='MIL', class='numeric'),
      INCTOT = list(acsname='PINCP', class='numeric')
    )
  )
  
  colNames <- lapply(meta, function(x) sapply(x, function(y) y[['acsname']]))
  colclass <- lapply(meta, function(x) sapply(unname(x), function(y) {
    setNames(y[['class']], y[['acsname']])
  }))
  
  
  
  if(Sys.info()['sysname'] == 'Windows') {
    cmd <- paste0("unzip -p '", PumsFile, "'")
  }
  
  if(Sys.info()['sysname'] == 'Linux') {
    cmd <- paste0("gunzip -cq '", PumsFile,"'")
  }
  
# Checks if it is a zip file or a bytefile
  if(grepl('.zip', PumsFile)) {
    df <- fread(cmd = cmd, 
                select = names(colclass[[type]]),
                colClasses = colclass[[type]])
  } else {
    df <- fread(PumsFile,
                select = names(colclass[[type]]),
                colClasses = colclass[[type]])
  }
  
  # Rename ACS PUMS fields to match legacy Census PUMS fields
  setnames(df, colNames[[type]], names(colNames[[type]]))
  
  return(df)
}

process_2000_pums <- function(PumsFile, GetPumas='ALL') {
  #Read in file and split out household and person tables
  Pums_ <- readLines(PumsFile)
  RecordType_ <- 
    as.vector(sapply(Pums_, function(x) {
      substr(x, 1, 1)
      }))
  H_ <- Pums_[RecordType_ == "H"]
  P_ <- Pums_[RecordType_ == "P"]
  rm(Pums_, RecordType_, PumsFile)
  
  #Define a function to extract specified PUMS data and put in data frame
  extractFromPums <- 
    function(Pums_, Fields_ls) {
      lapply(Fields_ls, function(x) {
        x$typeFun(unlist(lapply(Pums_, function(y) {
          substr(y, x$Start, x$Stop)
        })))
      })
    }
  
  #Identify the housing data to extract
  HFields_ls <-
    list(
      SERIALNO = list(Start = 2, Stop = 8, typeFun = as.character),
      PUMA5 = list(Start = 19, Stop = 23, typeFun = as.character),
      HWEIGHT = list(Start = 102, Stop = 105, typeFun = as.numeric),
      UNITTYPE = list(Start = 108, Stop = 108, typeFun = as.numeric),
      PERSONS = list(Start = 106, Stop = 107, typeFun = as.numeric),
      BLDGSZ = list(Start = 115, Stop = 116, typeFun = as.character),
      HINC = list(Start = 251, Stop = 258, typeFun = as.numeric)
    )
  
  #Extract the housing data and clean up
  H_df <- data.frame(extractFromPums(H_, HFields_ls), stringsAsFactors = FALSE)
  #Extract records for desired PUMAs
  if (GetPumas[1] != "ALL") {
    H_df <- H_df[H_df$PUMA5 %in% GetPumas,]
  }

  #Identify the person data to extract
  PFields_ls <-
    list(
      SERIALNO = list(Start = 2, Stop = 8, typeFun = as.character),
      AGE = list(Start = 25, Stop = 26, typeFun = as.numeric),
      WRKLYR = list(Start = 236, Stop = 236, typeFun = as.character),
      MILITARY = list(Start = 138, Stop = 138, typeFun = as.numeric),
      INCTOT = list(Start = 297, Stop = 303, typeFun = as.numeric)
    )
  
  #Extract the person data and clean up
  P_df <- data.frame(extractFromPums(P_, PFields_ls), stringsAsFactors = FALSE)
  #If not getting data for entire state, limit person records to be consistent
  if (GetPumas[1] != "ALL") {
    P_df <- P_df[P_df$SERIALNO %in% unique(H_df$SERIALNO),]
  }

  return( list('p' = P_df, 'h' = H_df) )
}
```

### PUMS data web-scraping

This has been automated one step further by scraping the data and
running the above functions on the files as they are read in.

``` R

# Downloads and processes legacy 2000 PUMS data
getDecPUMS <- function(STATE, output_dir = NA){
  #VARS
  state_codes <- fread('state.txt')
  state_codes <- setNames(state_codes$STATE, state_codes$STUSAB)
  base_url = 'https://www2.census.gov/census_2000/datasets/PUMS/FivePercent'
  
  if(length(STATE) > 2 & !is.numeric(STATE)) {
    STATE <- state.abb[match(toTitleCase(STATE),state.name)]
  }
  STATE_NAME <- state.name[match(toupper(STATE),state.abb)]
  
  
  if(!is.numeric(STATE)) STATE_NUM <- state_codes[toupper(STATE)]
  
  
  # Download the PUMS data to tempfile and load directly to data table
  url <- file.path(base_url,
                   STATE_NAME,
                   paste0('REVISEDPUMS5_', sprintf("%02d", STATE_NUM), '.TXT'))
  
  temp <- tempfile()
  download.file(url, temp)
  
  # Read .txt to data frames
  PUMS <- process_2000_pums(temp)
  
  # SAVE OUTPUT
  if(!is.na(output_dir)) {
    if(!dir.exists(output_dir)) dir.create(output_dir)
    fwrite(PUMS[['p']], file.path(output_dir, 'pums_persons.csv'))
    fwrite(PUMS[['h']], file.path(output_dir, 'pums_households.csv'))
  } else {
    return(PUMS)
  }
}

# Downloads and processes post-2000 PUMS
getACSPUMS <- function(STATE, YEAR='2000', GetPumas='ALL', output_dir, save_zip = T){
  #VARS
  try({
    state_codes <- fread('state.txt')
    state_codes <- setNames(state_codes$STATE, state_codes$STUSAB)
    })
  base_url = 'https://www2.census.gov/programs-surveys/acs/data/pums'
  
  
  if(length(STATE) > 2 & !is.numeric(STATE)) {
    STATE <- tolower(state.abb[match(toTitleCase(STATE),state.name)])
  }
  
 
  # Download the PUMS data to tempfile and load directly to data table
  PUMS <- lapply(c('p', 'h'), function(f) {
    url <- file.path(base_url, YEAR, '5-Year',
                     paste0('csv_', f, tolower(STATE), '.zip'))
    
    if(save_zip == F){
      temp <- tempfile()
    } else {
      temp <- file.path(output_dir, basename(url))
    }
    
    download.file(url, temp)
    df <- process_acs_pums(temp, type=f, GetPumas)
  
    return(df)
  })
  names(PUMS) <- c('p', 'h')
  
  
  # SAVE OUTPUT
  if(!is.na(output_dir)) {
    if(!dir.exists(output_dir)) dir.create(output_dir)
    fwrite(PUMS[['p']], file.path(output_dir, 'pums_persons.csv'))
    fwrite(PUMS[['h']], file.path(output_dir, 'pums_households.csv'))
  } else {
    return(PUMS)
  }
}
```

## VEPowertrainsandFuels

This case study explores the challenge of modifying the package code
itself rather than only the data. The objective of this case study is to
define a custom function which alters the default data values as they
are read into VisionEval during the build process.

This section walks users through modifying the data as they are read in
to VisionEval. Before modifying the code, a brief analysis is conducted
to define a modifying function and demonstrate the effects if the
modifications. The next subsection utilizes the function in the
`LoadDefaultValues.R` script to modify `hh_powertrain_prop.csv` as the
data are read in.

**Note:** The same results of this case study can be achieved by simply
modifying the hh_powertrain_prop.csv input file, but the code itself
will be modified for demonstration.

### 1. Data

`VEPowertrainsAndFuels\inst\extdata\hh_powertrain_prop.csv` are the
default powertrain proportions contained in the package, which resembles
the table below (the table is compressed to select years for clarity).
The file's purpose is to provide the proportion of vehicle powertrain
types by vehicle type (auto and light trucks) and vehicle vintage year.

| ModelYear | AutoPropIcev | AutoPropHev | AutoPropPhev | AutoPropBev | LtTrkPropIcev | LtTrkPropHev | LtTrkPropPhev | LtTrkPropBev |
|--------|--------|--------|--------|--------|--------|--------|--------|--------|
| 1975      | 1            | 0           | 0            | 0           | 1             | 0            | 0             | 0            |
| 2000      | 1            | 0           | 0            | 0           | 1             | 0            | 0             | 0            |
| 2010      | 0.8786       | 0.1213      | 0            | 0.0001      | 0.9820        | 0.0180       | 0             | 0            |
| 2020      | 0.8212       | 0.0788      | 0.0202       | 0.0798      | 0.9524        | 0.0143       | 0.0067        | 0.0266       |
| 2030      | 0.6676       | 0.0908      | 0.0358       | 0.2058      | 0.9093        | 0.0179       | 0.0106        | 0.0622       |
| 2040      | 0.5701       | 0.0922      | 0.0403       | 0.2974      | 0.8996        | 0.0191       | 0.0114        | 0.0698       |
| 2050      | 0.5198       | 0.0895      | 0.0407       | 0.3500      | 0.8916        | 0.0193       | 0.0119        | 0.0772       |

The table contains two powertrain proportions, the left-most four
columns are for automobiles (i.e., `AutoProp`) and the right-most are
for light trucks (i.e., `LtTrkProp`). Each will sum up to 1 (for a
rowsum of 2).

### 2. Analysis

To begin, the code snippets below conduct a brief exploratory analysis
to demonstrate visually what the data look like and how they will be
modified. Using some helper packages `ggplot2` and `reshape` we can
format the data for visualization. **Note:** These packages are not
necessary for modifying the data in VisionEval, but are used for
formatting and plotting in this case study.

    # Additional packages
    library(ggplot2)
    library(reshape)

    # Load data, uncomment it to run in your project
    hh_powertrain_prop <- read.csv('.YOUR_PACKAGE_DIRECTORY/inst/extdata/hh_powertrain_prop.csv')

    melted_powertrains <- reshape::melt(hh_powertrain_prop, id.vars = 'ModelYear')

    ggplot(data = melted_powertrains) +
      geom_line(aes(x=ModelYear, y=value, color=variable)) +
      scale_y_continuous(labels=scales::percent) +
      theme_classic()

![Household Powertrain
Proportions](images/hh_powertrain_prop_view.png){width="75%"}

We can see that battery electric vehicles (BEV), specifically
automobiles, are projected to make up the majority of vehicles bought in
future years. This causes the share of internal combustion engine to
decline proportionally.

Let us assume that the state government is deciding whether to
aggressively promote BEV cars starting in 2025. The policies cause the
share of alternative powertrains (BEV, HEV, and PHEV) to increase more
over time. To model this increase, we will use an arbitrary function
which adds to the current value of $x$ (i.e., the proportion) at a
quadratic rate.

$$
f(x) = x + x^2 (1 - x)
$$ We then create a wrapper function that adjusts each of the
alternative powertrains using our custom modeling function. To ensure
that the proportions sum up to 1 for autos and light trucks,
respectively, we then calculate the remaining proportion of ICE
powertrains by subtracting the proportion of alternative powertrains.

    # Wrapper function to adjust the powertrain data
    adjust_powertrain <- function(powertrain_df, start_year) {
      # Define our adjustment functions
      adj_fun <- function(xv) xv + (xv^2) * (1 - xv)

      # Which columns to modify
      cols <- colnames(powertrain_df)
      ev_cols <- cols[grepl('Hev|Phev|Bev', cols)]
      ice_cols <- cols[grepl('Icev', cols)]

      # Create the modified data frame
      df_mod <- powertrain_df
      yrs_idx <- df_mod$ModelYear > start_year

      # Adjust the alternate powertrain data (BEV, PHEV, HEV) data
      df_mod[yrs_idx, ev_cols] <- apply(powertrain_df[yrs_idx, ev_cols], 2, adj_fun)

      # Subtract the amount of remaining internal combustion engines (ICE)
      for(x in ice_cols){
        sum_cols <- ev_cols[grepl(gsub('Icev', '', x), ev_cols)]
        df_mod[yrs_idx, eval(x)] <- 1 - rowSums(df_mod[yrs_idx, sum_cols])
      }

      return(df_mod)
    }

The adjusted inputs can be combined with the existing data. The combined
plot shows an noticeable increase in alternative powertrain vehicle
shares for later vintage years.

    hh_powertrain_prop_high <- adjust_powertrain(hh_powertrain_prop, 2025)

    melted_powertrains <- rbind(
      cbind(reshape::melt(hh_powertrain_prop, id.vars = 'ModelYear'), type='existing'),
      cbind(reshape::melt(hh_powertrain_prop_high, id.vars = 'ModelYear'), type='high')
      )

    ggplot(data = melted_powertrains) +
      geom_line(aes(x=ModelYear, y=value, color=variable, linetype=type)) +
      scale_y_continuous(labels=scales::percent) +
      theme_classic()

![Adjusted Household Powertrain
Proportions](images/hh_powertrain_prop_adjustedview.png){width="75%"}

### 3. Function modification

Once a model user is satisfied with the effects that are represented by
applying the modifying function, the `LoadDefaultValues.R` can be edited
to include the function. Beginning on line #422, the R script
initializes the household powertrain datastore input, then loads in the
CSV file using `processEstimationInputs`. We can insert the new function
after the data has been loaded but before it has been stored and cleaned
up at `PowertrainFuelDefaults_ls$HhPowertrain_df <- HhPowertrain_df`.

    #----------------------------------------
    #Household vehicle powertrain proportions
    #----------------------------------------
    #Specify input file attributes
    Inp_ls <- items(
      item(
        NAME = "ModelYear",
        TYPE = "integer",
        PROHIBIT = c("NA", "< 0"),
        ISELEMENTOF = "",
        UNLIKELY = "",
        TOTAL = ""
      ),
      item(
        NAME =
          items("AutoPropIcev",
                "AutoPropHev",
                "AutoPropPhev",
                "AutoPropBev",
                "LtTrkPropIcev",
                "LtTrkPropHev",
                "LtTrkPropPhev",
                "LtTrkPropBev"),
        TYPE = "double",
        PROHIBIT = c("NA", "< 0", "> 1"),
        ISELEMENTOF = "",
        UNLIKELY = "",
        TOTAL = ""
      )
    )
    #Load and process data
    HhPowertrain_df <-
      processEstimationInputs(
        Inp_ls,
        "hh_powertrain_prop.csv",
        "LoadDefaultValues.R")
    #Check whether all years are present
    Years_ <- 1975:2050
    if (!all(Years_ %in% HhPowertrain_df$ModelYear)) {
      stop(paste(
        "File 'hh_powertrain_prop.csv' must have values for at least the years",
        "from 1975 through 2050", sep = " "))
    }
    #Check that powertrain proportion are 0 when powertrain characteristics are NA
    Msg_ <- character(0)
    for (ty in c("Auto", "LtTrk")) {
      for (pt in c("Icev", "Hev", "Phev", "Bev")) {
        PtType <- paste0(ty, pt)
        PropName <- paste0(ty, "Prop", pt)
        CharName <- paste0(ty, pt, "Mpg")
        if (pt == "Bev") CharName <- paste0(ty, pt, "Mpkwh")
        Prop_ <- HhPowertrain_df[[PropName]]
        Char_ <- PowertrainFuelDefaults_ls$LdvPowertrainCharacteristics_df[[CharName]]
        if (any(Prop_[is.na(Char_)] != 0)) {
          Msg <- paste0(
            "hh_powertrain_prop.csv file error. Non-zero proportion(s) for ",
            PropName, " where NA values in ldv_powertrain_characteristics.csv for ",
            CharName)
          Msg_ <- c(Msg_, Msg)
        }
      }
    }
    if (length(Msg_) != 0) {
      stop(paste(Msg_, collapse = ", "))
    }

    #>>>>>>>>> NEW FUNCTION BEGINS
    adjust_powertrain <- function(powertrain_df, start_year) {
      # Define our adjustment functions
      adj_fun <- function(xv) xv + (xv^2) * (1 - xv)

      # Which columns to modify
      cols <- colnames(powertrain_df)
      ev_cols <- cols[grepl('Hev|Phev|Bev', cols)]
      ice_cols <- cols[grepl('Icev', cols)]

      # Create the modified data frame
      df_mod <- powertrain_df
      yrs_idx <- df_mod$ModelYear > start_year

      # Adjust the alternate powertrain data (BEV, PHEV, HEV) data
      df_mod[yrs_idx, ev_cols] <- apply(powertrain_df[yrs_idx, ev_cols], 2, adj_fun)

      # Subtract the amount of remaining internal combustion engines (ICE)
      for(x in ice_cols){
        sum_cols <- ev_cols[grepl(gsub('Icev', '', x), ev_cols)]
        df_mod[yrs_idx, eval(x)] <- 1 - rowSums(df_mod[yrs_idx, sum_cols])
      }

      return(df_mod)
    }

    #<<<<<<<<< END OF NEW FUNCTION

    #Add to PowertrainFuelDefaults_ls and clean up
    PowertrainFuelDefaults_ls$HhPowertrain_df <- HhPowertrain_df
    rm(Inp_ls, HhPowertrain_df)

### 4. Build

The previous step generated the R data files, and you will need to
re-build and re-install the VEPowertrainsAndFuels package for VisionEval
to use this new input data. Any of the three build processes described
above can be used.

Once the package re-build is complete, your new powertrain data will be
ready to use in a VisionEval model run.
